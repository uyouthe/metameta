{"version":3,"sources":["metameta.js"],"names":["Metameta","options","_runtime","bind","start","stop","push","clear","getQueue","on","off","getOptions","interval","bias","queue","clock","previousResult","undefined","events","tick","next","isFinished","fn","wasStarted","i","pop","nextFunction","nextArgs","unshift","apply","setInterval","clearInterval","args","prevLength","length","slice","event","cb"],"mappings":"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","file":"metameta.min.map","sourceRoot":"..","sourcesContent":["class Metameta {\n  constructor (options) {\n    this._runtime = this._runtime.bind(this)\n    this.start = this.start.bind(this)\n    this.stop = this.stop.bind(this)\n    this.push = this.push.bind(this)\n    this.clear = this.clear.bind(this)\n    this.getQueue = this.getQueue.bind(this)\n    this.on = this.on.bind(this)\n    this.off = this.off.bind(this)\n    this.getOptions = this.getOptions.bind(this)\n\n    this.options = {\n      interval: options.interval || 20,\n      bias: options.bias || 50\n    }\n    this.queue = []\n    this.clock = null\n    this.previousResult = undefined\n\n    this.events = {\n      // called on every function being executed\n      tick: (previousResult, next) => {},\n\n      // called on execution start\n      start: () => {},\n\n      // called on execution stop and\n      // notifies you whether there were function to execute or not\n      stop: (isFinished) => {},\n\n      // called on push. Receives the whole queue,\n      // the new function and whether this push has started the execution\n      push: (queue, fn, wasStarted) => {},\n\n      // called on queue wiping\n      clear: () => {}\n    }\n  }\n\n  _runtime () {\n    for (let i = 0; i < this.options.bias; i++) {\n      // destructurize next function\n      const next = this.queue.pop()\n\n      if (next) {\n        const nextFunction = next[0]\n        const nextArgs = next[1]\n\n        // pass previous execution result as the first argument\n        nextArgs.unshift(previousResult)\n\n        // call the actual function\n        this.previousResult = nextFunction.apply(nextArgs)\n        this.events['tick'](previousResult, next)\n      } else {\n        this.stop()\n        this.events['stop'](true)\n      }\n    }\n  }\n\n  start () {\n    this.clock = setInterval(this.options.interval || 20, this._runtime)\n    this.events['start']()\n  }\n\n  stop () {\n    if (this.clock) {\n      clearInterval(this.clock)\n\n      // notify whether there's actually was the execution process\n      this.events['stop'](false)\n    }\n    this.events['stop'](true)\n  }\n\n  push (args) {\n    const prevLength = this.queue.length\n    const fn = [args[0], [...args.slice(1)]]\n    this.queue.push(fn)\n\n    if (prevLength === 0) {\n      this.start()\n    }\n\n    this.events['push'](queue, fn, prevLength === 0)\n  }\n\n  clear () {\n    this.queue = []\n    this.events['clear']()\n  }\n\n  getQueue () {\n    return this.queue\n  }\n\n  getOptions () {\n    return this.options\n  }\n\n  on (event, cb) {\n    this.events[event] = cb\n  }\n\n  off (event) {\n    this.events[event] = () => {}\n  }\n}\n"]}